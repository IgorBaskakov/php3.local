<?php

class Foo
{
    public $value;
    public $self;
}

for ($i = 0; $i < 1000000; $i++) {
    $obj = new Foo;
    $obj->value = rand(0, 1000000);
    $obj->self = $obj;

    if ($i % 500 === 0) {
        echo '----------' . "\n";
        echo 'Запрошено ' . memory_get_usage(false) . ' байт памяти' . "\n";
        echo 'Выделено ' . memory_get_usage(true) . ' байт памяти' . "\n";
    }

    if ($i === 999999) {
        echo 'done';
    }
}

// Тестирование потребления памяти на PHP версии 7.1 (x64):
// Раз в 500 итераций показания выделяемой памяти остаются неизменными в размере 2097152 байт.
// Объем запрашиваемой памяти растет до объема чуть более 1Мб, и после выполнения очередных 10000 итераций, запрашиваемая
// память резко падает. Таким образом объем запрашиваемой памяти не достигает объема выделенной памяти, из-за чего
// выделяемая память не растет. Пример наглядно показывает работу сборщика мусора, который предотвращает утечку памяти и
// подчищает неиспользуемые переменные, тем самым освобождая память.

// Тестирование потребления памяти на PHP версии 5.5 (x64):
// Запрашиваемая память растет до объема около 3Мб, потом падает до 1Мб. После 10000 итераций запрашиваемая память
// остается неизменной в размере 1214928 байт. Выделяемая память растет до отметки 3407872 байт, а потом остается неизменной.
// Здесь также garbage collector не дает течь памяти, очищая от неиспользуемых переменных.
//
// Вывод: в ранних версиях PHP объем запрашиваемой и выделяемой памяти под переменные был значительно выше.
//